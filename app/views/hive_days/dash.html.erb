<div id="left_column">
  <%= render :partial => "sidebar" %>
</div>
<div id="right_column">
  <div id="right_column_top">
    <div id="dash_menu">
      <%= link_to 'Dashboard', 'dash', :id => 'main_dash_link' %> | <%= link_to 'History', 'dash', :id => 'history_dash_link' %></div>
      <div id="dash_content">
      </div>
  </div>
  <div id="right_column_bottom">
    <div id="recent_activity">
      <%= render :partial => "recent_activity" %>
    </div>
  </div>
</div>

<script type="text/javascript">
  $(document).ready(function(){
    $("#dash_content").html('<%= escape_javascript(render :partial => "main_dash") %>');
    
    $('#main_dash_link').click(function (event) {
      $("#dash_content").html('<%= escape_javascript(render :partial => "main_dash") %>');
      event.preventDefault(); // Prevent link from following its href
    });

    $('#history_dash_link').click(function (event) {
      $("#dash_content").html('<%= escape_javascript(render :partial => "history_dash") %>');
      event.preventDefault(); // Prevent link from following its href
    });
  });
</script>


<script type="text/javascript">
// //
// // donut graphs
// //
// 
// for(i=0;i<3;i++)
// {
  // var dataset = {
    // percentages: [0, 0, 600, 100, 50],
  // };
//   
  // var width = 200,
      // height = 182,
      // radius = Math.min(width, height) / 2;
//   
  // if(i < 2)
  // {
    // var color = d3.scale.ordinal()
        // .range(["#f5f5f5", "#dbdad6", "#fe9600"]);
  // }
  // else
  // {
    // var color = d3.scale.ordinal()
        // .range(["#f5f5f5", "#dbdad6", "#73b71a"])
  // }
//   
// //  var color = d3.scale.category20();
//   
  // var pie = d3.layout.pie()
      // .sort(null);
//   
  // var arc = d3.svg.arc()
      // .innerRadius(50)
      // .outerRadius(80);
//   
  // var svg = d3.select("#right_column_top").append("svg")
      // .attr("width", width)
      // .attr("height", height)
      // .append("g")
      // .attr("transform", "translate(" + width / 2 + ", 100)");
//   
  // var path = svg.selectAll("path")
      // .data(pie(dataset.percentages))
    // .enter().append("path")
      // .attr("fill", function(d, i) { return color(i); })
      // .attr("d", arc);
// }
// 
// 
// var the_svgs = $("svg");
// var last_svg = the_svgs[the_svgs.length-1];
// $(last_svg).after("</br>");
// 
// //
// // bar graph
// //
// 
// // Data
// var dataset = [];
// for (var i=0; i<50; i++){
  // var num = Math.round(Math.random() * 20)+7;
  // dataset.push(num);
// }
// 
// //Width and Height
// var w = 800;
// var h = 100;
// var gap = 1;
// 
// //Create SVG Element
// var svg = d3.select("#right_column_top")
          // .append("svg")
          // .attr("width", w)
          // .attr("height", h);
// 
// var bars = svg.selectAll("rect")
           // .data(dataset)
           // .enter()
           // .append("rect")
           // .attr("x", 0)
           // .attr("y", function(d, i){
              // return h-d*3;
           // })
           // .attr("width", function(d, i){
              // return (w/2)/dataset.length;// - gap;
           // })
           // .attr("height", 0)
           // .attr("fill", "teal")
           // .attr("opacity", function(d,i){
              // return Math.round(d)/100 + 0.2;
           // })
           // .transition()
           // .attr("height", function(d, i){
              // return d*3;
           // })
           // .attr("x", function(d, i){
             // return i * (w/dataset.length);
           // })
           // .duration(function(d,i){
            // return i*200;
          // })
           // .delay(100);

//
// line graph
//

// $.get('initial_dash_data', function(data) {
  // /* implementation heavily influenced by http://bl.ocks.org/1166403 */
//  
  // // define dimensions of graph
  // var m = [80, 80, 80, 80]; // margins
  // var w = 1000 - m[1] - m[3]; // width
  // var h = 500 - m[0] - m[2]; // height
//   
  // // create a simple data array that we'll plot with a line (this array represents only the Y values, X will just be the index location)
  // var x_data = data.times
  // var y_data = data.weights;//[3, 6, 2, 7, 5, 2, 0, 3, 8, 9, 2, 5, 9, 3, 6, 3, 6, 2, 7, 5, 2, 1, 3, 8, 9, 2, 5, 9, 2, 7];
// 
  // // X scale will fit all values from data[] within pixels 0-w
  // var x = d3.scale.ordinal().domain(d3.range(x_data.length)).rangeRoundBands([0, w], .1);
  // // Y scale will fit values from 0-10 within pixels h-0 (Note the inverted domain for the y-scale: bigger is up!)
  // var y = d3.scale.linear().domain([(d3.min(y_data) - 10), (d3.max(y_data) + 10)]).range([h, 0]);
    // // automatically determining max range can work something like this
    // // var y = d3.scale.linear().domain([0, d3.max(data)]).range([h, 0]);
// 
  // // create a line function that can convert data[] into x and y points
  // var line = d3.svg.line()
    // // assign the X function to plot our line as we wish
    // .x(function(d,i) { 
      // // verbose logging to show what's actually being done
      // //console.log('Plotting X value for data point: ' + d + ' using index: ' + i + ' to be at: ' + x(i) + ' using our xScale.');
      // // return the X coordinate where we want to plot this datapoint
      // return x(i); 
    // })
    // .y(function(d) { 
      // // verbose logging to show what's actually being done
      // //console.log('Plotting Y value for data point: ' + d + ' to be at: ' + y(d) + " using our yScale.");
      // // return the Y coordinate where we want to plot this datapoint
      // return y(d); 
    // })
// 
    // // Add an SVG element with the desired dimensions and margin.
    // var graph = d3.select("#graph").append("svg:svg")
          // .attr("width", w + m[1] + m[3])
          // .attr("height", h + m[0] + m[2])
        // .append("svg:g")
          // .attr("transform", "translate(" + m[3] + "," + m[0] + ")");
// 
    // // create xAxis
    // var xAxis = d3.svg.axis().scale(x).tickSize(-h).tickValues(x_data);
// //        var xAxis = d3.svg.axis().scale(x).tickSize(-h).ticks(y_data.length);
    // // Add the x-axis.
    // graph.append("svg:g")
          // .attr("class", "x axis")
          // .attr("transform", "translate(0," + h + ")")
          // .call(xAxis);
// 
// 
    // // create left yAxis
    // var yAxisLeft = d3.svg.axis().scale(y).orient("left");//.ticks(4).orient("left");
    // // Add the y-axis to the left
    // graph.append("svg:g")
          // .attr("class", "y axis")
          // .attr("transform", "translate(-25,0)")
          // .call(yAxisLeft);
//     
      // // Add the line by appending an svg:path element with the data line we created above
    // // do this AFTER the axes above so that the line is above the tick-lines
      // graph.append("svg:path").attr("d", line(y_data));
// });
</script>



<!-- THIS IS ALL THE ORIGINAL GRAPH STUFF. HOLDING ONTO IT BECAUSE IT MIGHT COME IN HANDY -->
<script>
  // $(document).ready(function () {
    // create_line_graph("");
//     
    // $.get('extra_dash_data', function(data) {
      // console.log(data);
      // console.log(data.dates);
      // console.log(data.weights);
//       
      // function update_bar_graph(i)
      // {
        // console.log(i);
      // }
// 
       // // Data
      // var dataset = [];
      // /*for (var i=0; i<40; i++){
        // var num = Math.round(Math.random() * 70)+7;
        // dataset.push(num);
      // }*/
//       
      // for(var i=0; i < data.weights.length; i++)
      // {
        // dataset.push(data.weights[i]);
      // }
//       
      // //Width and Height
      // var w = 1240;
      // var h = 800;
      // var gap = 1;
//       
      // //Create SVG Element
      // var svg = d3.select("#bar_graph")
                // .append("svg")
                // .attr("width", w)
                // .attr("height", h);
//       
      // var bars = svg.selectAll("rect")
                 // .data(dataset)
                 // .enter()
                 // .append("rect")
                 // .on("click", function(d, i)
                 // {
                   // $("#graph").html("");
                   // create_line_graph(i);
                 // })
                 // .attr("id", function(d, i){
                   // return "bar_" + i;
                 // })
                 // .attr("x", 0)
                 // .attr("y", function(d, i){
                    // return h-d*3;
                 // })
                 // .attr("width", function(d, i){
                    // return w/dataset.length - gap;
                 // })
                 // .attr("height", 0)
                 // .attr("fill", "teal")
                 // .attr("opacity", function(d,i){
                    // return Math.round(d)/100 + 0.2;
                 // })
                 // .transition()
                 // .attr("height", function(d, i){
                    // return d*3;
                 // })
                 // .attr("x", function(d, i){
                    // return i * (w/dataset.length);
                 // })
                 // .duration(function(d,i){
                  // return i*200;
                // })
                 // .delay(100);
//       
      // var labels = svg.selectAll("text")
                    // .data(dataset)
                    // .enter()
                    // .append("text")
                    // .text(function(d){
                      // return d;
                    // })
                    // .attr("x", function(d, i){
                    // return i * (w/dataset.length) + 26;
                     // })
                     // .attr("y", function(d, i){
                        // return h-d*3 + 15;
                     // })
                     // .attr("font-family", "sans-serif")
                     // .attr("font-size", "0px")
                     // .attr("fill", "white")
                     // .attr("text-anchor", "middle")
                     // .transition()
                     // .attr("font-size", "11px")
                     // .delay(function(d,i){
                  // return i*200;
                // })
                     // .duration(500);
// 
// 
// 
// 
    // });
  // });
//   
  // function create_line_graph(i)
  // {
    // $.get('initial_dash_data/' + i, function(data) {
      // /* implementation heavily influenced by http://bl.ocks.org/1166403 */
//      
      // // define dimensions of graph
      // var m = [80, 80, 80, 80]; // margins
      // var w = 1400 - m[1] - m[3]; // width
      // var h = 500 - m[0] - m[2]; // height
//       
      // // create a simple data array that we'll plot with a line (this array represents only the Y values, X will just be the index location)
      // var x_data = data.times
      // var y_data = data.weights;//[3, 6, 2, 7, 5, 2, 0, 3, 8, 9, 2, 5, 9, 3, 6, 3, 6, 2, 7, 5, 2, 1, 3, 8, 9, 2, 5, 9, 2, 7];
// 
      // // X scale will fit all values from data[] within pixels 0-w
      // var x = d3.scale.ordinal().domain(d3.range(x_data.length)).rangeRoundBands([0, w], .1);
      // // Y scale will fit values from 0-10 within pixels h-0 (Note the inverted domain for the y-scale: bigger is up!)
      // var y = d3.scale.linear().domain([(d3.min(y_data) - 10), (d3.max(y_data) + 10)]).range([h, 0]);
        // // automatically determining max range can work something like this
        // // var y = d3.scale.linear().domain([0, d3.max(data)]).range([h, 0]);
//     
      // // create a line function that can convert data[] into x and y points
      // var line = d3.svg.line()
        // // assign the X function to plot our line as we wish
        // .x(function(d,i) { 
          // // verbose logging to show what's actually being done
          // //console.log('Plotting X value for data point: ' + d + ' using index: ' + i + ' to be at: ' + x(i) + ' using our xScale.');
          // // return the X coordinate where we want to plot this datapoint
          // return x(i); 
        // })
        // .y(function(d) { 
          // // verbose logging to show what's actually being done
          // //console.log('Plotting Y value for data point: ' + d + ' to be at: ' + y(d) + " using our yScale.");
          // // return the Y coordinate where we want to plot this datapoint
          // return y(d); 
        // })
//     
        // // Add an SVG element with the desired dimensions and margin.
        // var graph = d3.select("#graph").append("svg:svg")
              // .attr("width", w + m[1] + m[3])
              // .attr("height", h + m[0] + m[2])
            // .append("svg:g")
              // .attr("transform", "translate(" + m[3] + "," + m[0] + ")");
//     
        // // create xAxis
        // var xAxis = d3.svg.axis().scale(x).tickSize(-h).tickValues(x_data);
// //        var xAxis = d3.svg.axis().scale(x).tickSize(-h).ticks(y_data.length);
        // // Add the x-axis.
        // graph.append("svg:g")
              // .attr("class", "x axis")
              // .attr("transform", "translate(0," + h + ")")
              // .call(xAxis);
//     
//     
        // // create left yAxis
        // var yAxisLeft = d3.svg.axis().scale(y).orient("left");//.ticks(4).orient("left");
        // // Add the y-axis to the left
        // graph.append("svg:g")
              // .attr("class", "y axis")
              // .attr("transform", "translate(-25,0)")
              // .call(yAxisLeft);
//         
          // // Add the line by appending an svg:path element with the data line we created above
        // // do this AFTER the axes above so that the line is above the tick-lines
          // graph.append("svg:path").attr("d", line(y_data));
    // });
  // }
</script>

